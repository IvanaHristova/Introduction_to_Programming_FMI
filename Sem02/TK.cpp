#include <iostream>
using namespace std;

int main() 
{
    int a = 68;
    char c = 'C'; // Hint: 'A' = 65
    double d = 97.5;
    bool b = false;

    int output1 = d + 10.2; // 107
    /*
    97.5 + 10.2 = 107.7, но тъй като тази стойност се присвоява на променлива от целочислен тип, 
    се извършва неявно преобразуване и частта след десетичната запетайка се "изрязва".
    */

    int output2 = (int)d + 10.7; // 107
    /*
    Първо правим явно преобразуване на d към целочислен тип и след това събираме с 10.7, 
    тоест получаваме 97 + 10.7 = 107.7. Output2 е от тип, който очаква цяло число, така че
    всичко след десетичната запетая се игнорира.
    */

    int output3 = c; // 67
    /*
    След като 'А' = 65 и в ASCII таблицата главните латински букви са записани поредно,
    то 'C' = 67. Оutput3 е от целочислен тип, значи се взима числовата стойност на символа.
    */

    int output4 = 'F' + b; // 70
    /*
    След като 'А' = 65, то 'F' = 70. Променливата b е инициализирана със стойност false,
    която се изразява с 0, тоест 70 + 0 = 70.
    */

    int output5 = (b + 1); // 1
    /*
    Променливата b има стойност 0, защото е false от инициализацията, следователно 0 + 1 = 1.
    */

    int output6 = (a -= 1); // 67
    /*
    Изразът (а -= 1) е еквивалентен запис на (а = а - 1), тоест ние променяме стойността на а и
    тя става а = 68 - 1, тоест вече а = 67. Тъй като а е променлива, то ние можем да променяме стойността й
    в хода на нашата програма и в случая от този ред до следваща промяна output6 = 67 и а = 67.
    */

    char output7 = (a + b % 2); // C
    /*
    Променливата а има стойност 67, тъй като в output6 -> (а -= 1) задава нова стойност на нашата променлива.
    Булевата променлвиа b има стойност false, тоест 0. Следователно изразът ни има стойност (67 + 0 % 2).
    Операторът % е с по-висок приоритет от +, значи поредността на изпълнение на операциите е 
    (67 + (0 % 2)) = (67 + 0) = 67. Присвоявайки тази стойност на променлива от символен тип,
    числото се замества със символа, на който отговоря, което в случая на 67 е 'C'. 
    */

    char output8 = (b += 5) + 'A'; // B
    /*
    Променливата b e от булев тип, а при него всичко != 0 се смята за 1. При b += 5 имаме b = b + 5, тоест
    b = 0 + 5. Но макар че 0 + 5 = 5, 5 != 0, значи имаме b = 1. 
    Така целият израз е равен на (1 + 65) = 66. Тази стойност се присвоява на променлива от символен тип, значи
    трябва да я заместим със символ. Взимайки предвид, че 'А' = 65, то 66 трябва да е 'B'.
    */

    double output9 = a / 100; // 0
    /*
    Променливата а е от целочислен тип. При деление на две цели числа резултатът е цяло число, независимо че се 
    присвоява на променлива от тип double. (67 / 100) = 0.
    Ако имахме израза: 
    double output9 = (double)a / 100; можете да тествате какво ще се получи. За да бъде резултатът дробно число,
    трябва поне едно от числата да е от такъв тип.
    */

    double output10 = (d / 10); // 9.75
    /*
    Променливата d е от тип за реално число, тоест след делене пак ще получим реално число. Output10 също е от реален
    тип, така че данни не се губят. (97.5 / 10) = 9.75.
    */

    cout << output1 << endl;
    cout << output2 << endl;
    cout << output3 << endl;
    cout << output4 << endl;
    cout << output5 << endl;
    cout << output6 << endl;
    cout << output7 << endl;
    cout << output8 << endl;
    cout << output9 << endl;
    cout << output10 << endl;

    return 0;
}